var R=Object.defineProperty;var O=(a,n,e)=>n in a?R(a,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[n]=e;var i=(a,n,e)=>O(a,typeof n!="symbol"?n+"":n,e);import{L as p,b as h,c as E,a as C,G as x,K as P}from"./s5kuwhN6.js";import{E as U,i as m,x as T,h as q,b as A,g as S,G as j,r as N}from"./DPLBeim1.js";class u{constructor(){i(this,"register",{})}static create(n=[]){const e=new u;return n.forEach(t=>e.merge(t)),e}registerLoader(n,e){const t=n,{RESOLVE:s}=t;if(s)(!this.register[s.type]||e)&&(this.register[s.type]={Construct:t,...s});else throw new Error("No resolve metadata found on Loader.")}loaderFromURL(n){const[e,t]=n.split("#"),s=`.${e.split(".").pop()}`;let r=null;if(t){const o=this.register[t];r=o?new o.Construct(e):null}else if(s){const o=Object.values(this.register).filter(l=>l.extensions.filter(c=>s===c).length>0);r=o.length>0?new o[0].Construct(e):null}else throw new Error(`Couldn't parse url when trying to resolve: ${n}`);if(r)return r;throw new Error(`Couldn't find Loader to handle url : ${n} / ${s}`)}merge(n){Object.entries(n.register).forEach(([,e])=>{this.registerLoader(e.Construct,!0)})}}var L;(function(a){a.STATS_UPDATE="stats-update"})(L||(L={}));const g=class g extends U{constructor(e={}){super();i(this,"opts");i(this,"_queue",new Map);i(this,"_locked",!1);this.opts=e,e.concurrency=e.concurrency||g.DEFAULT_CONCURRENCY}add(e,t){if(this._locked)throw new Error(`LoaderScheduler is locked. Cannot add new loaders. This may be because new loaders should not be added outside the Vue lifecycle. URL: ${e.url||void 0}`);this._queue.has(e)||(this._queue.set(e,{loader:e,cb:t}),this.next())}next(){const e=this.stats(),t=Math.max(0,this.opts.concurrency-e.loading),{queued:s}=e.loaders;t>0&&e.queued>0?(s.sort((r,o)=>o.priority-r.priority),s.slice(0,t).forEach(r=>{r.start().then(()=>{this._queue.get(r).cb(r),this.next()})})):e.queued,this.emit(L.STATS_UPDATE,e)}lock(){this._locked=!0}unlock(){this._locked=!1}dispose(){this._queue.clear()}stats(){const e=[],t=[],s=[],r=[];for(const o of this._queue.values()){const l=o.loader.state;l===p.COMPLETE?e.push(o.loader):l===p.QUEUED?t.push(o.loader):l===p.LOADING?o.loader instanceof _||s.push(o.loader):l===p.ERROR&&r.push(o.loader)}return{queued:t.length,loading:s.length,complete:e.length,errored:r.length,loaders:{queued:t,loading:s,complete:e,errored:r}}}};i(g,"DEFAULT_CONCURRENCY",10);let f=g;const k=a=>Object.getPrototypeOf(a)===Object.prototype,d=class d extends h{constructor(e,t={}){super("",t);i(this,"_loaders",[]);i(this,"_resolvable",[]);i(this,"_resolver");i(this,"_scheduler");i(this,"_returnRecord",!1);if(t.resolver&&t.resolver instanceof u&&(this._resolver=t.resolver),t.scheduler&&t.scheduler instanceof f&&(this._scheduler=t.scheduler),e instanceof Array)this._returnRecord=!1,e.forEach((s,r)=>{typeof s=="string"?this._resolvable.push([r.toString(),s]):this.addLoader(s)});else if(k(e))this._returnRecord=!0,Object.entries(e).forEach(([s,r])=>{if(r instanceof h)r.id=s,this.addLoader(r);else if(typeof r=="string")this._resolvable.push([s,r]);else throw new Error("Unhandled LoaderRecord type.")});else throw new Error("Unknown supplied loader format.")}get resolver(){return this._resolver}get scheduler(){return this._scheduler}get loaders(){return this._loaders}addLoader(e){this._loaders.indexOf(e)===-1&&(this._loaders.push(e),e.setParent(this))}start(){return this.resolve(!0),super.start()}schedulerNearestParent(){if(this._scheduler)return this._scheduler;{let e=null,t=this.parent;for(;t&&!e;)e=t.scheduler,t=t.parent;return e}}async load(){const e=this.schedulerNearestParent();return e?new Promise(t=>{this.loaders.length===0&&t(this.data),this.loaders.forEach(s=>{const r=()=>{this.emitProgress()};s.on(E.LOAD_PROGRESS,r),e.add(s,()=>{s.removeListener(E.LOAD_PROGRESS,r);const o=this.progress();o.count===o.total&&t(this.data)})})}):this.loaders.length===0?this.data:Promise.all(this.loaders.map(t=>t.start().then(()=>{this.emitProgress()}))).then(()=>this.data)}progress(){const e=this.loaders.reduce((t,s)=>{const r=s.progress();return t.count+=r.count,t.total+=r.total,t.percentage+=r.percentage,t},{count:0,percentage:0,total:0});return this.loaders.length>0?e.percentage/=this.loaders.length:e.percentage,e}resolverChain(){const e=this._resolver?[this._resolver]:[];let t=this.parent;for(;t;)t.resolver&&e.unshift(t.resolver),t=t.parent;return e}resolve(e=!0){if(this._resolvable.length>0){const t=this.resolverChain(),s=u.create(t);this._resolvable.forEach(([r,o],l)=>{const c=s.loaderFromURL(o);c&&(c.id=r,this._loaders.push(c),this._resolvable[l]=null)}),this._resolvable=this._resolvable.filter(r=>r!==null)}e&&this._loaders.forEach(t=>{t instanceof d&&t.resolve(!0)})}loadersRecursive(){return this._loaders.flatMap(e=>e instanceof d?e.loadersRecursive():e)}async cancel(){this.loaders.forEach(e=>e.cancel())}async dispose(){this.loaders.forEach(e=>e.dispose()),this._scheduler&&this._scheduler.dispose()}get data(){return this._returnRecord?this._loaders.reduce((e,t)=>(e[t.id]=t.data,e),{}):this._loaders.map(e=>e.data)}};i(d,"DEFAULT_CONCURRENCY",10);let _=d;class D extends _{constructor(n={}){super([],{resolver:new u,scheduler:new f({concurrency:n.concurrency||f.DEFAULT_CONCURRENCY})}),n.loaders&&n.loaders.forEach(e=>this.registerLoader(e))}registerLoader(n){this.resolver.registerLoader(n)}lock(){this.scheduler.lock()}unlock(){this.scheduler.unlock()}}const F=a=>({retainBlob:!1,...a});class v extends h{constructor(){super(...arguments);i(this,"_blob",null);i(this,"_request",null);i(this,"_data")}get blob(){return this._blob}async load(e){const t=F(e),s=new Image;return new Promise(r=>{const o=this._request=new XMLHttpRequest;o.open("GET",this.url,!0),o.responseType="arraybuffer",o.onload=()=>{const l=new Blob([o.response]);s.src=URL.createObjectURL(l),t.retainBlob&&(this._blob=l),this._data=s,r(s)},o.onprogress=l=>{this.setAccuratePercentage(l.loaded/l.total),this.emitProgress()},o.onloadstart=()=>{},o.send()})}async cancel(){this._data&&(this._data.src="",this._data=null),this._request&&(this._request.abort(),this._request=null),this._blob=null}async dispose(){this.cancel()}get data(){return this._data}}i(v,"RESOLVE",{type:"image-blob",extensions:[".jpg",".jpeg",".png",".gif",".webp"]});const I=a=>({decode:!1,crossOrigin:"",decoding:"async",...a});class y extends h{constructor(){super(...arguments);i(this,"_data")}async load(e){const t=I(e),s=new Image;return new Promise((r,o)=>{s.addEventListener("error",c=>{o(c.error)});const l=c=>{this._data=c,r(c)};s.addEventListener("load",()=>t.decode?s.decode().then(c=>l(c)):l(s)),s.decoding=t.decoding,s.crossOrigin=t.crossOrigin,s.src=this.url})}async cancel(){this._data&&(this._data.src="")}async dispose(){this._data=null}get data(){return this._data}}i(y,"RESOLVE",{type:"image",extensions:[".jpg",".jpeg",".png",".gif",".webp"]});class w extends h{constructor(e,t){super(e,t);i(this,"_controller");i(this,"_data");this._controller=new AbortController}async load(e){return new Promise((t,s)=>{fetch(this.url,{...e,signal:this._controller.signal}).then(r=>{if(r.status===200)return r.json();s({status:r.status,statusText:r.statusText})}).then(r=>(this._data=r,r)).then(t)})}async cancel(){this._controller&&this._controller.abort()}async dispose(){this._data=null}get data(){return this._data}}i(w,"RESOLVE",{type:"json",extensions:[".json"]});const G=(a,n)=>{const e=m(a,()=>null,!0),t=n.add(e==null?void 0:e.current),s={chain:[...e?e.chain:[],t],current:t,root:e?e.root:t,parent:e?e.current:void 0};return T(a,s),q(()=>{n.remove(s.current,s.parent)}),s},b="LOADER_CHAIN",M=a=>{let n;return a?n=G(b,{add:e=>{const t=new D(a);return e&&e.addLoader(t),t},remove:(e,t)=>{t&&e.cancel()}}):n=m(b),n.root},Y={__name:"LoaderProvider",setup(a,{expose:n}){const e=A(),t=M({concurrency:10,loaders:[w,y,v,C,x,P]});return t.on(E.LOAD_PROGRESS,s=>{const{percentage:r}=s.progress;e.setLoadProgress(r)}),S(()=>{}),j(()=>{t.dispose()}),n({context:t}),(s,r)=>N(s.$slots,"default")}};export{_ as L,Y as _,G as d,b as n};
